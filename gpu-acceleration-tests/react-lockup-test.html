<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React-like Lockup Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .status {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success { background-color: #d4edda; color: #155724; }
        .warning { background-color: #fff3cd; color: #856404; }
        .error { background-color: #f8d7da; color: #721c24; }
        .info { background-color: #d1ecf1; color: #0c5460; }
        pre {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #6c757d; cursor: not-allowed; }
        .ui-test {
            background: #e9ecef;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .counter {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
    </style>
</head>
<body>
    <h1>🔬 React-like UI Lockup Test</h1>
    <p>This test recreates the React environment conditions that cause WASM inference to lock up the UI.</p>

    <div class="test-section">
        <h2>1. UI Responsiveness Test</h2>
        <div class="ui-test">
            <div>Counter (should keep updating): <span class="counter" id="counter">0</span></div>
            <div>Spinner (should keep spinning): <span class="spinner"></span></div>
            <div>Current Time: <span id="currentTime">--:--:--</span></div>
        </div>
        <button onclick="startUIUpdates()">Start UI Updates</button>
        <button onclick="stopUIUpdates()">Stop UI Updates</button>
    </div>

    <div class="test-section">
        <h2>2. React-like State Management</h2>
        <div id="reactState"></div>
        <button onclick="initReactLikeState()">Initialize React-like State</button>
    </div>

    <div class="test-section">
        <h2>3. WASM Inference Tests</h2>
        <div id="wasmResults"></div>
        <button onclick="testStandardWASM()">Test Standard WASM (should work)</button>
        <button onclick="testReactLikeWASM()">Test React-like WASM (may lock up)</button>
        <button onclick="testAsyncWASM()">Test Async WASM (should fix lockup)</button>
    </div>

    <div class="test-section">
        <h2>4. Performance Comparison</h2>
        <div id="performanceResults"></div>
        <button onclick="runPerformanceComparison()">Run Performance Comparison</button>
    </div>

    <div class="test-section">
        <h2>5. Test Logs</h2>
        <pre id="testLogs"></pre>
        <button onclick="clearLogs()">Clear Logs</button>
    </div>

    <script type="module">
        // Simulate React-like environment
        let uiUpdateInterval;
        let counter = 0;
        let reactState = {
            isLoading: false,
            isProcessing: false,
            results: null,
            error: null
        };
        let logs = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            const logEntry = `[${timestamp}] ${type.toUpperCase()}: ${message}`;
            logs.push(logEntry);
            console.log(logEntry);
            updateLogDisplay();
        }

        function updateLogDisplay() {
            const logElement = document.getElementById('testLogs');
            if (logElement) {
                logElement.textContent = logs.join('\n');
                logElement.scrollTop = logElement.scrollHeight;
            }
        }

        function clearLogs() {
            logs = [];
            updateLogDisplay();
        }

        // UI Update functions
        window.startUIUpdates = function() {
            if (uiUpdateInterval) clearInterval(uiUpdateInterval);
            
            uiUpdateInterval = setInterval(() => {
                counter++;
                document.getElementById('counter').textContent = counter;
                document.getElementById('currentTime').textContent = new Date().toLocaleTimeString();
            }, 100); // Update every 100ms
            
            log('UI updates started (should continue during inference)');
        };

        window.stopUIUpdates = function() {
            if (uiUpdateInterval) {
                clearInterval(uiUpdateInterval);
                uiUpdateInterval = null;
            }
            log('UI updates stopped');
        };

        // React-like state management
        function updateReactState(newState) {
            reactState = { ...reactState, ...newState };
            const stateElement = document.getElementById('reactState');
            if (stateElement) {
                stateElement.innerHTML = `
                    <div class="status ${reactState.error ? 'error' : reactState.isLoading ? 'warning' : 'success'}">
                        <strong>React State:</strong><br>
                        Loading: ${reactState.isLoading}<br>
                        Processing: ${reactState.isProcessing}<br>
                        Results: ${reactState.results ? 'Available' : 'None'}<br>
                        Error: ${reactState.error || 'None'}
                    </div>
                `;
            }
        }

        window.initReactLikeState = function() {
            updateReactState({ isLoading: false, isProcessing: false, results: null, error: null });
            log('React-like state initialized');
        };

        // ONNX Runtime setup
        let ort;
        let session;

        async function setupONNXRuntime() {
            if (ort) return;
            
            log('Loading ONNX Runtime...');
            ort = await import('./onnx/ort.webgpu.min.mjs');
            
            // Configure like React frontend
            ort.env.wasm.wasmPaths = './onnx/';
            ort.env.wasm.numThreads = 16; // Same as React frontend
            ort.env.wasm.simd = true;
            ort.env.wasm.proxy = false; // Same as React frontend
            ort.env.wasm.initTimeout = 60000;
            
            if (ort.env.webgpu) {
                ort.env.webgpu.validateInputContent = false;
            }
            
            log('ONNX Runtime configured like React frontend');
        }

        async function loadModel() {
            if (session) return session;
            
            await setupONNXRuntime();
            
            log('Loading model...');
            updateReactState({ isLoading: true });
            
            try {
                // Same configuration as React frontend
                const sessionOptions = {
                    executionProviders: ['webgpu', 'wasm', 'cpu'],
                    preferredOutputLocation: 'gpu-buffer',
                    graphOptimizationLevel: 'all',
                    enableMemPattern: true,
                    enableCpuMemArena: true,
                    executionMode: 'parallel',
                    logSeverityLevel: 3,
                    logVerbosityLevel: 0,
                    enableProfiling: false,
                };
                
                session = await ort.InferenceSession.create('./trading_card_detector.onnx', sessionOptions);
                
                // Check actual execution provider
                const sessionAny = session;
                const actualProvider = sessionAny.executionProviders || sessionAny._executionProviders || [];
                log(`Model loaded. Actual execution provider: ${JSON.stringify(actualProvider)}`);
                
                updateReactState({ isLoading: false, results: 'Model loaded' });
                return session;
                
            } catch (error) {
                log(`Model loading failed: ${error.message}`, 'error');
                updateReactState({ isLoading: false, error: error.message });
                throw error;
            }
        }

        // Create test tensor (same size as React frontend)
        function createTestTensor() {
            const inputSize = 1088 * 1088 * 3;
            const testData = new Float32Array(inputSize);
            for (let i = 0; i < inputSize; i++) {
                testData[i] = Math.random();
            }
            return new ort.Tensor('float32', testData, [1, 3, 1088, 1088]);
        }

        // Test functions
        window.testStandardWASM = async function() {
            const resultDiv = document.getElementById('wasmResults');
            resultDiv.innerHTML = '<div class="status info">🔄 Testing standard WASM inference...</div>';
            
            try {
                await loadModel();
                const inputTensor = createTestTensor();
                
                log('Starting standard WASM inference...');
                const startTime = performance.now();
                
                const results = await session.run({
                    [session.inputNames[0]]: inputTensor
                });
                
                const endTime = performance.now();
                log(`Standard WASM inference completed in ${(endTime - startTime).toFixed(2)}ms`);
                
                resultDiv.innerHTML = `
                    <div class="status success">✅ Standard WASM inference successful</div>
                    <pre>Time: ${(endTime - startTime).toFixed(2)}ms
Output shape: ${Object.keys(results).map(key => results[key].dims).join(', ')}</pre>
                `;
                
            } catch (error) {
                log(`Standard WASM test failed: ${error.message}`, 'error');
                resultDiv.innerHTML = `<div class="status error">❌ Standard WASM test failed: ${error.message}</div>`;
            }
        };

        window.testReactLikeWASM = async function() {
            const resultDiv = document.getElementById('wasmResults');
            resultDiv.innerHTML = '<div class="status warning">🔄 Testing React-like WASM inference (may cause lockup)...</div>';
            
            try {
                await loadModel();
                const inputTensor = createTestTensor();
                
                // Simulate React-like conditions that cause lockup
                updateReactState({ isProcessing: true });
                
                log('Starting React-like WASM inference (simulating React conditions)...');
                const startTime = performance.now();
                
                // This is where the lockup happens in React - synchronous heavy computation
                // without yielding control back to the browser
                const results = await session.run({
                    [session.inputNames[0]]: inputTensor
                });
                
                const endTime = performance.now();
                log(`React-like WASM inference completed in ${(endTime - startTime).toFixed(2)}ms`);
                
                updateReactState({ isProcessing: false, results: 'Inference complete' });
                
                resultDiv.innerHTML = `
                    <div class="status success">✅ React-like WASM inference successful (no lockup detected)</div>
                    <pre>Time: ${(endTime - startTime).toFixed(2)}ms
Output shape: ${Object.keys(results).map(key => results[key].dims).join(', ')}</pre>
                `;
                
            } catch (error) {
                log(`React-like WASM test failed: ${error.message}`, 'error');
                updateReactState({ isProcessing: false, error: error.message });
                resultDiv.innerHTML = `<div class="status error">❌ React-like WASM test failed: ${error.message}</div>`;
            }
        };

        window.testAsyncWASM = async function() {
            const resultDiv = document.getElementById('wasmResults');
            resultDiv.innerHTML = '<div class="status info">🔄 Testing async WASM inference (should prevent lockup)...</div>';
            
            try {
                await loadModel();
                const inputTensor = createTestTensor();
                
                updateReactState({ isProcessing: true });
                
                log('Starting async WASM inference with proper yielding...');
                const startTime = performance.now();
                
                // Yield control to browser before inference
                await new Promise(resolve => setTimeout(resolve, 0));
                
                // Use timeout protection and async scheduling
                const results = await Promise.race([
                    (async () => {
                        // Additional yield before actual inference
                        await new Promise(resolve => setTimeout(resolve, 1));
                        return session.run({
                            [session.inputNames[0]]: inputTensor
                        });
                    })(),
                    new Promise((_, reject) => {
                        setTimeout(() => {
                            reject(new Error('Inference timeout - preventing lockup'));
                        }, 30000);
                    })
                ]);
                
                // Yield control after inference
                await new Promise(resolve => setTimeout(resolve, 0));
                
                const endTime = performance.now();
                log(`Async WASM inference completed in ${(endTime - startTime).toFixed(2)}ms`);
                
                updateReactState({ isProcessing: false, results: 'Async inference complete' });
                
                resultDiv.innerHTML = `
                    <div class="status success">✅ Async WASM inference successful (lockup prevented)</div>
                    <pre>Time: ${(endTime - startTime).toFixed(2)}ms
Output shape: ${Object.keys(results).map(key => results[key].dims).join(', ')}</pre>
                `;
                
            } catch (error) {
                log(`Async WASM test failed: ${error.message}`, 'error');
                updateReactState({ isProcessing: false, error: error.message });
                resultDiv.innerHTML = `<div class="status error">❌ Async WASM test failed: ${error.message}</div>`;
            }
        };

        window.runPerformanceComparison = async function() {
            const resultDiv = document.getElementById('performanceResults');
            resultDiv.innerHTML = '<div class="status info">🔄 Running performance comparison...</div>';
            
            const results = [];
            
            try {
                await loadModel();
                const inputTensor = createTestTensor();
                
                // Test standard inference
                log('Testing standard inference performance...');
                for (let i = 0; i < 3; i++) {
                    const startTime = performance.now();
                    await session.run({ [session.inputNames[0]]: inputTensor });
                    const endTime = performance.now();
                    results.push({ type: 'Standard', time: endTime - startTime });
                }
                
                // Test async inference
                log('Testing async inference performance...');
                for (let i = 0; i < 3; i++) {
                    const startTime = performance.now();
                    await new Promise(resolve => setTimeout(resolve, 0));
                    const inferenceResults = await Promise.race([
                        (async () => {
                            await new Promise(resolve => setTimeout(resolve, 1));
                            return session.run({ [session.inputNames[0]]: inputTensor });
                        })(),
                        new Promise((_, reject) => {
                            setTimeout(() => reject(new Error('Timeout')), 30000);
                        })
                    ]);
                    await new Promise(resolve => setTimeout(resolve, 0));
                    const endTime = performance.now();
                    results.push({ type: 'Async', time: endTime - startTime });
                }
                
                // Calculate averages
                const standardAvg = results.filter(r => r.type === 'Standard').reduce((sum, r) => sum + r.time, 0) / 3;
                const asyncAvg = results.filter(r => r.type === 'Async').reduce((sum, r) => sum + r.time, 0) / 3;
                
                resultDiv.innerHTML = `
                    <div class="status success">✅ Performance comparison completed</div>
                    <pre>Standard WASM: ${standardAvg.toFixed(2)}ms average
Async WASM: ${asyncAvg.toFixed(2)}ms average
Overhead: ${(asyncAvg - standardAvg).toFixed(2)}ms (${((asyncAvg - standardAvg) / standardAvg * 100).toFixed(1)}%)

Individual Results:
${results.map(r => `${r.type}: ${r.time.toFixed(2)}ms`).join('\n')}</pre>
                `;
                
            } catch (error) {
                log(`Performance comparison failed: ${error.message}`, 'error');
                resultDiv.innerHTML = `<div class="status error">❌ Performance comparison failed: ${error.message}</div>`;
            }
        };

        // Initialize
        window.addEventListener('load', () => {
            log('React-like lockup test initialized');
            initReactLikeState();
            startUIUpdates();
        });
    </script>
</body>
</html>


