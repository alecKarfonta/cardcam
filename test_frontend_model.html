<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Frontend Model</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        .container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .input-section, .output-section {
            flex: 1;
            min-width: 300px;
        }
        canvas {
            border: 2px solid #ccc;
            max-width: 100%;
        }
        .controls {
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .status.loading { background-color: #fff3cd; }
        .status.success { background-color: #d4edda; }
        .status.error { background-color: #f8d7da; }
        .results {
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>üÉè Trading Card Detector Test</h1>
    <p>Test the updated ONNX model with proper OBB rotation support</p>
    
    <div class="container">
        <div class="input-section">
            <h2>Input</h2>
            <div class="controls">
                <input type="file" id="imageInput" accept="image/*">
                <button onclick="loadTestImage()">Load Test Image</button>
            </div>
            <canvas id="inputCanvas" width="640" height="480"></canvas>
        </div>
        
        <div class="output-section">
            <h2>Detection Results</h2>
            <div class="controls">
                <button onclick="runDetection()" id="detectBtn">Run Detection</button>
                <button onclick="loadModel()" id="loadBtn">Load Model</button>
            </div>
            <canvas id="outputCanvas" width="640" height="480"></canvas>
        </div>
    </div>
    
    <div id="status" class="status">Ready to load model</div>
    <div id="results" class="results" style="display: none;"></div>

    <script type="module">
        import * as ort from './frontend/public/onnx/ort.all.min.mjs';
        
        let session = null;
        let currentImageData = null;
        
        // Configure ONNX Runtime
        ort.env.wasm.wasmPaths = './frontend/public/onnx/';
        ort.env.wasm.numThreads = 1;
        ort.env.wasm.simd = false;
        ort.env.wasm.proxy = false;
        
        window.loadModel = async function() {
            const statusDiv = document.getElementById('status');
            const loadBtn = document.getElementById('loadBtn');
            
            try {
                statusDiv.className = 'status loading';
                statusDiv.textContent = 'Loading ONNX model...';
                loadBtn.disabled = true;
                
                session = await ort.InferenceSession.create('./frontend/public/models/trading_card_detector.onnx', {
                    executionProviders: ['wasm'],
                    graphOptimizationLevel: 'basic'
                });
                
                statusDiv.className = 'status success';
                statusDiv.textContent = `‚úÖ Model loaded successfully! Input: ${session.inputNames[0]}, Output: ${session.outputNames[0]}`;
                document.getElementById('detectBtn').disabled = false;
                
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = `‚ùå Failed to load model: ${error.message}`;
                console.error('Model loading error:', error);
            } finally {
                loadBtn.disabled = false;
            }
        };
        
        window.loadTestImage = function() {
            // Load the test image (cam.png)
            const img = new Image();
            img.onload = function() {
                const canvas = document.getElementById('inputCanvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                
                currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                document.getElementById('detectBtn').disabled = !session;
            };
            img.src = './cam.png';
        };
        
        document.getElementById('imageInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    const canvas = document.getElementById('inputCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);
                    
                    currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    document.getElementById('detectBtn').disabled = !session;
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
        });
        
        function preprocessImage(imageData) {
            const { width, height, data } = imageData;
            const targetSize = 1088;
            
            // Letterbox resize
            const r = Math.min(targetSize / width, targetSize / height);
            const newW = Math.round(width * r);
            const newH = Math.round(height * r);
            const padX = Math.floor((targetSize - newW) / 2);
            const padY = Math.floor((targetSize - newH) / 2);
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = targetSize;
            canvas.height = targetSize;
            
            // Fill with gray padding
            ctx.fillStyle = '#808080';
            ctx.fillRect(0, 0, targetSize, targetSize);
            
            // Draw resized image
            const srcCanvas = document.createElement('canvas');
            const srcCtx = srcCanvas.getContext('2d');
            srcCanvas.width = width;
            srcCanvas.height = height;
            srcCtx.putImageData(imageData, 0, 0);
            
            ctx.drawImage(srcCanvas, 0, 0, width, height, padX, padY, newW, newH);
            
            const resized = ctx.getImageData(0, 0, targetSize, targetSize);
            const tensorData = new Float32Array(1 * 3 * targetSize * targetSize);
            const pixels = resized.data;
            
            for (let i = 0; i < targetSize * targetSize; i++) {
                const p = i * 4;
                tensorData[i] = pixels[p] / 255.0;
                tensorData[i + targetSize * targetSize] = pixels[p + 1] / 255.0;
                tensorData[i + 2 * targetSize * targetSize] = pixels[p + 2] / 255.0;
            }
            
            return { tensorData, r, padX, padY };
        }
        
        window.runDetection = async function() {
            if (!session || !currentImageData) {
                alert('Please load model and image first');
                return;
            }
            
            const statusDiv = document.getElementById('status');
            const detectBtn = document.getElementById('detectBtn');
            const resultsDiv = document.getElementById('results');
            
            try {
                statusDiv.className = 'status loading';
                statusDiv.textContent = 'Running detection...';
                detectBtn.disabled = true;
                
                const startTime = performance.now();
                
                // Preprocess image
                const { tensorData, r, padX, padY } = preprocessImage(currentImageData);
                const inputTensor = new ort.Tensor('float32', tensorData, [1, 3, 1088, 1088]);
                
                // Run inference
                const results = await session.run({ images: inputTensor });
                const output = results.output0;
                
                const inferenceTime = performance.now() - startTime;
                
                console.log('Output shape:', output.dims);
                console.log('Output data length:', output.data.length);
                console.log('First 20 values:', Array.from(output.data.slice(0, 20)));
                
                // Parse detections: [1, 300, 7] format
                const detections = [];
                const [, maxDetections, featuresPerDetection] = output.dims;
                
                for (let i = 0; i < maxDetections; i++) {
                    const offset = i * featuresPerDetection;
                    const detection = output.data.slice(offset, offset + featuresPerDetection);
                    
                    // Skip empty detections
                    if (detection.every(val => val === 0)) continue;
                    
                    const [cx, cy, w, h, confidence, classId, angle] = detection;
                    
                    if (confidence > 0.25) {
                        // Convert back to original image coordinates
                        const origCx = (cx - padX) / r;
                        const origCy = (cy - padY) / r;
                        const origW = w / r;
                        const origH = h / r;
                        
                        detections.push({
                            cx: origCx, cy: origCy, w: origW, h: origH,
                            confidence, classId, angle
                        });
                    }
                }
                
                // Draw results
                drawDetections(detections);
                
                statusDiv.className = 'status success';
                statusDiv.textContent = `‚úÖ Detection completed in ${inferenceTime.toFixed(2)}ms`;
                
                resultsDiv.style.display = 'block';
                resultsDiv.innerHTML = `
                    <h3>Results</h3>
                    <p><strong>Detections found:</strong> ${detections.length}</p>
                    <p><strong>Processing time:</strong> ${inferenceTime.toFixed(2)}ms</p>
                    <p><strong>Model output shape:</strong> [${output.dims.join(', ')}]</p>
                    <h4>Detection Details:</h4>
                    ${detections.map((d, i) => `
                        <div>Detection ${i + 1}: confidence=${d.confidence.toFixed(3)}, angle=${d.angle.toFixed(3)}rad</div>
                    `).join('')}
                `;
                
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = `‚ùå Detection failed: ${error.message}`;
                console.error('Detection error:', error);
            } finally {
                detectBtn.disabled = false;
            }
        };
        
        function drawDetections(detections) {
            const canvas = document.getElementById('outputCanvas');
            const ctx = canvas.getContext('2d');
            
            // Copy input image
            const inputCanvas = document.getElementById('inputCanvas');
            canvas.width = inputCanvas.width;
            canvas.height = inputCanvas.height;
            ctx.drawImage(inputCanvas, 0, 0);
            
            // Draw detections
            detections.forEach((det, i) => {
                const { cx, cy, w, h, confidence, angle } = det;
                
                // Draw rotated bounding box
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(angle);
                
                ctx.strokeStyle = `hsl(${i * 60}, 70%, 50%)`;
                ctx.lineWidth = 3;
                ctx.strokeRect(-w/2, -h/2, w, h);
                
                // Draw center point
                ctx.fillStyle = ctx.strokeStyle;
                ctx.fillRect(-3, -3, 6, 6);
                
                ctx.restore();
                
                // Draw confidence label
                ctx.fillStyle = 'white';
                ctx.fillRect(cx - 30, cy - h/2 - 25, 60, 20);
                ctx.fillStyle = 'black';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${confidence.toFixed(2)}`, cx, cy - h/2 - 10);
            });
        }
        
        // Auto-load test image on page load
        window.addEventListener('load', () => {
            loadTestImage();
        });
    </script>
</body>
</html>
